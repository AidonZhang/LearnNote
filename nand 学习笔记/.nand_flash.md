
### nand flash common concept ###![](http://i.imgur.com/QXJWOXZ.png)
- LFI 固件目录，每个模块的位置 大小
- data block 只读; free block 可以转换的block; blog 
   block可以写的block
- pair page 配对页
- 为什么brec阶段才建表，因为nand hwsc建了表格，为什么需要重建表格呢？
- 为什么part 和zone 表缓存大小需要*4？（72*4 = 288） 
- block的spare里面内容 
- rw erase单位 read(sector)write()erase(block)
- PageBitmap
- row address
- flash cap = chip_qua * block_qua_per_chip * page_qua_per_block
- eslc

### nand_brec flowchat ###
1. InitParam()初始化全局变量
2. 校验brec以及Logo的有效性，扫描flash判断是否匹配链接是否正常，并初始化相关驱动参数
3. NandRRInit();
4. Set_NandFeq();
5. DispStarting();
6. Brec_CodeCheck();
7. BrecCreateTable()
8. sSTST_CodeTstRpr()校验
9. sd区恢复完成，后面不会再有SD写操作，merge SD区日志块

	    //这样处理后，后面读SD操作都直接读data block
	    FTL_FlushPageCache();
	    BrecMerge(UPGRADE_SD_MERGE);
	    UpdateAllZonePartToFlash();	
10. sSYSCFG_Lanucher();//内核代码搬运到RAM中0xff1000//
11. zoneInfo的LogicBlockNum信息会在量产后存在brec的代码中，这个值启动时不能变化
### 建表流程 ###
1. (BrecGetTable() 取得所有的zone表和part表

		从FIRST_BLOCK_IN_LOGIC开始 先填满 <part表块表> 填充0xff
		把part表恢复到 brec之后的第一个好块里面

2. BrecRebuildPartition(PARTITION_SYSTEM)
3. BrecRebuildPartition(PARTITION_USER)
4. CompletionCreateTable()
5. BrecMerge(BREC_CT_MERGE)
### RW flowchat ###
### about merge ###
